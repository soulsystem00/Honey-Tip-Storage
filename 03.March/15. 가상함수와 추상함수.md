# 가상함수와 추상함수

가상함수는 virtual 키워드를 사용해서 만든 함수이다.  
추상함수는 abstract 키워드를 사용해서 만든 함수이다.  

2개의 차이라고 한다면  
선언에서 차이가 있고  
오버라이딩에서 차이가 있다.  

가상함수는 아래와 같이 선언을 하게 된다.  

```
public virtual void Foo()
{
    Console.WriteLine("Hello world");
}
```

가상함수는 일반 함수와 크게 다르지가 않다.  

본문을 선언 할 수 있으며  
본문이 선언되어 있기 때문에  
언제든지 가져가다 사용해도 된다.  
물론 재정의를 해서 사용을 해도 된다.  
뭔가 확장성이 있는 느낌이다.  

추상함수는 아래와 같이 선언을 하게 된다.  

```
pubilc abstract void Foo();
```

추상함수는 가상함수와 다르게  
본문이 없다.  

그렇기 때문에 추상함수는 그대로 가져다가 사용하지 못한다.  
만약에 추상 함수가 있는 클래스를 상속받게 된다면  
무조건 추상 함수는 재정의 해주어야 한다.  
어찌보면 강제성을 띄는 느낌이다.  

추상클래스 내부에선 구현을 해주지 않아도 되고  
호출도 가능하긴 하지만  
엄연히 따지면 구조를 만드는 것 뿐이지  
기능을 만드는 역할은 아닌 것 같다.  

이 2개의 차이가 애매할 순 있는데  
쓰다보니 약간씩 차이를 두게 되는 것 같다.  
상속 받은 객체에서 무조건 재정의를 하게 만들고 싶으면 추상 함수를 사용하고  
굳이 재정의를 안해도 되는 함수 같은 경우에는 가상함수를 사용하고 있다.  

약간 기능적으로 보자면  
빠져도 기능적으로 아무 이상이 없는 경우에는 가상함수를  
빠지게 되면 기능적으로 치명적인 영향을 미치는 경우에는 추상함수를 사용해서  
절대로 빠지지 않게 만들어주는 역할을 하는 것 같다.  

그리고 이렇게 만들게 된다면  
추후에 기능을 추가할 때 유용하게 사용할 수 있게 되는 것 같다.  
어차피 호출을 하는 함수는 똑같은데  
가상 / 추상함수를 통해 다양하게 동작하게 만들수 있으니  
나는 그냥 가상 / 추상 함수만 구현해준다면  
이후에는 그대로 로직을 따라갈 수 있기 때문이다.  

아 그리고  
2개 모두 재정의라는 개념이 들어가는데  
결국 상속 받은 클래스에서 해당 함수에 접근이 가능해야한다는 소리가 된다   

상속을 받는다 하더라도 private 필드나 메소드에는 접근이 불가능하기 때문에  
private으로 선언된 가상함수, 추상함수에 접근이 불가능해지고  
재정의는 해주어야 하고  
이 둘에 모순이 발생하기 때문에  
가상, 추상함수는 private이 될 수 없다.  


</br>
</br>
</br>
</br>
</br>

### 잡담   

```
뭔가 뭔가임
```