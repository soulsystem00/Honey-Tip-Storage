# 코루틴은 겹칠 수 있다

```
StartCoroutine(CoABCD());

IEnumrator CoABCD()
{
    yield return null;
}
```

StartCorotine을 통해 코루틴을 동작 시킨다.  
그런데 여기서 착각을 하는 것이 있는데  
코루틴을 여러번 호출하면 이전의 코루틴은 무시 된다고 생각하는 경우가 있는 것 같다.

물론 그럴 가능성도 있다.  
다만 코루틴이 어떠한 동작을 하느냐에 달린 것이지  
절대 무시되느 것이 아니다.  

보통 코루틴은 n초 뒤에 실행될 때 사용되는 경우가 많은 것 같은데  
처음에는 까맣게 시작하고 n초뒤에 하얗게 칠하는 코드가 있다고 해보자  

이 코드를 여러번 동작하게 되면  
n초뒤 하얗게 칠한다 하더라도 다른 코루틴에 의해 다시 까맣게 칠해질 것이다  
그리고 호출을 멈추는 순간 n초뒤에 하얗게 화면이 변할 것이다.  

결과만 보자면 n초뒤에 화면이 하얗게 변하는 동작 자체는 이뤄졌다는 것인데  
겉모습만 보고 내가 원하던대로 동작했다고 착각하는 경우가 있다.  
그리고 더 나아가서 이전에 호출된 코루틴은 동작을 멈추고  
최신에 동작시킨 코루틴만 영향을 줬다고 생각하는 경우도 발생한다는 것이다.  

중요한 것은 코루틴이 계속해서 무시된 것이 아니라  
계속해서 실행이 되었기 때문에 이러한 결과가 가능해졌다는 것이다.  

물론 이걸 의도하고 사용하면 상관이 없겠지만  
그렇지 않은 경우에는 굉장히 큰 오류가 발생할 수도 있다.  

당연히 이를 해결 할 수 있는 방법도 있다.  
바로 코루틴을 캐싱하고 직접 멈추는 방법이다.  

```
Coroutine coCache

coCashe = StartCoroutine(CoABCD());

StopCorutine(coCache);
```

이렇게 캐싱을 해두었다가 StopCorutine을 사용해서 멈추는 방법도 있다.  
그런데 이것 역시 의도치 않은 결과를 만들 수 있다.  

왜냐하면 코루틴은 일종의 비동기로 동작하게 되는데  
그러면 어디서 어떻게 멈출지 예상할 수 없어지기 때문이다.  

```
IEnumrator CoABCD()
{
    image.Color = Color.white;
    yield return new WaitforSeconds(1f);
    image.Color = Color.blue;
    yield return new WaitforSeconds(1f);
    image.Color = Color.black;
}
```

대충 요런 코드가 있다고 했을 때  
코루틴은 독립적으로 돌아가기 때문에  
내가 StopCoroutine을 호출 했을 때  
이미지가 흰색인 상태일 수도 있고 파란색인 상태일 수도 있고 검은색인 상태 일 수도 있다.  

그런데 StopCoroutine은 무조건 파란색인 상태에서만  
호출이 되도록 코드를 만들었다면 굉장한 오류를 만들 수 있을 것이다.  

그렇기 때문에 나는 코루틴을 캐싱하거나 Stop을 호출해주지 않는다.  

최대한 동기적으로 짜려고 하고  
Stop이 필요없도록 짜려고 한다.  
</br>
</br>
</br>
</br>
</br>

### 잡담
```
```