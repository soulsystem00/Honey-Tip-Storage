# 벡터 회전

유니티로 벡터를 사용하다보니<br/>
이걸 회전시킬 일이 굉장히 많이 발생했는데<br/>
그때마다 방법을 찾아서 적용을 시켰음<br/>
근데 이걸 그냥 정리해보기로 함<br/>
<br/>


### 1. 쿼터니온 사용&nbsp;&nbsp;&nbsp;`x, z 벡터의 회전`<br/>
```
Vector3 result = Quaternion.Euler(0, angle, 0) * originalVec;
```

쿼터니온을 활용해서 x, z 값만 있는 벡터를 회전시키는 방법임<br/>
회전 축은 y를 사용함<br/>
<br/>
유의사항은 쿼터니온의 곱은 교환법칙이 성립하지 않는다는 것임<br/>
그래서 무조건 앞에 쿼터니온 뒤에 벡터가 와야함<br/>
<br/>

### 1-1. 쿼터니온 사용 2&nbsp;&nbsp;&nbsp;`x, y 벡터의 회전`<br/>
```
Vector3 result = Quaternion.Euler(0, 0, angle) * originalVec;
```

쿼터니온을 활용해서 x, y 값만 있는 벡터를 회전시키는 방법임<br/>
회전 축은 z를 사용함<br/>
<br/>
1번 방법하고 같은데 사용하는 축이 다름<br/><br/>
y,z 벡터 회전하고 싶으면 x 축 회전 시키면 됨<br/>
<br/>

### 2. 회전행렬 사용&nbsp;&nbsp;&nbsp; `x, y 벡터의 회전`<br/>

$$\begin{bmatrix}cosθ&-sinθ\\\sinθ&cosθ\end{bmatrix}
*
\begin{bmatrix}x\\\y\end{bmatrix}
=   
\begin{bmatrix}x*cosθ-y*sinθ\\\x*sinθ+y*cosθ\end{bmatrix}$$
= (x * cosθ - y * sinθ, x * sinθ + y * cosθ)
<br/><br/><br/><br/><br/><br/>

$$ {\left\lbrack \matrix{2 & 3 \cr 4 & 5} \right\rbrack} 
* \left\lbrack \matrix{1 & 0 \cr 0 & 1} \right\rbrack
= \left\lbrack \matrix{2 & 3 \cr 4 & 5} \right\rbrack
$$

<br/>
<br/>
음 회전행렬을 이용한 변환임<br/>
대충 마지막에 괄호안에 있는 식대로 함수 만들어서 매개변수로 때리면 회전이 됨<br/>
사용하기는 쿼터니온이 편하긴 한데<br/>
단순히 2차원 회전 정도만 사용할 거면 이게 훨씬 직관적임<br/>
쿼터니온으로 들어가는 순간 갑자기 이상하게 회전할 가능성이 높음<br/>
<br/>
만약에 x, z벡터를 회전시키고 싶으면 x, z값 넣어서 계산하면 됨<br/>
<br/>
<br/>
<br/>
### 잡담
```
만약에 3차원으로 회전을 시키고 싶으면 정말 복잡해짐

복잡해지는 만큼 고려해야 할 것도 많아지고
원치않는 결과가 나올 수도 있음

일단 회전시키고 싶은 축을 생각해야하고
각 축을 적용시키는 순서에 따라 원치않는 결과가 나올 수 있음

단순히 회전행렬을 (3,3) * (3,1)로 확장시키면 되는 문제가 아님

그러면 이제 쿼터니온을 사용하던가 해야하는데 쿼터니온은 또 직관적이지가 않음
특히나 유니티에서 회전에서 인터페이스로는 오일러 각을 제공하는데
내부적으로는 Quaternion을 채택하고 있어서 둘 간의 괴리가 있음

예를 들어 인스펙터 창에서는 x축으로 45도 y축으로 45도 회전했다고 보여지지만
코드 까서 로그 찍어보면 쿼터니온 각 원소에 이상한 값이 들어가 있는 걸 볼 수 있음

다행히도 Quaternion.Euler가 있어서 이거 유용하게 사용하는 중임
```

$\vec{v} = \begin{bmatrix} X \\\ Y \end{bmatrix}$