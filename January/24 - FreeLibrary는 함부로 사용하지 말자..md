# FreeLibrary는 함부로 사용하지 말자.

디버깅을 하던 도중</br>
현재 사용하고 있는 에셋을 살펴봐야 할 때가 왔다.</br>
왜냐하면 에셋의 함수를 호출 할 때마다 메모리 누수가 일어났기 때문이다.</br>
</br>
그렇게 함수를 살펴보던 도중</br>
해당 코드 안에 주석처리가 되어있는 코드 하나를 발견했다.</br>
주석의 내용은 대충 `크래시가 일어나면 이거 쓰세요` 요런 내용이었다.</br>
</br>
처음 보는 코드였고 딱봐도 DLL을 건들이는 코드라서 불안하긴 했지만</br>
좋은게 좋은거지 라고 생각하면서 주석 해제를 해서 실행을 시켜보았다.</br>
대충 꺼지면 dll을 반환시키는 코드였다.</br>
</br>
그래서 꺼지는 것 까지는 아주 잘 동작했다.</br>
그런데 켜질 때 문제가 발생했다.</br>
이전에는 발생하지 않았던 크래시가 발생하는 것이었다.</br>
</br>
그래서 그냥 로드를 시켜주면 되겠지 생각을 하고</br>
켜는 부분에 로드를 시켜주는 함수를 추가해주었다.</br>
당연히 될 줄 알았지만 당연하게 정상작동을 하지 않았고</br>
이전에는 플레이를 껐다가 키면 오류가 해결이 되었지만</br>
이건 해결되지 않고 이전에 정상 작동 하던 기능도 끄는 함수를 동작만 시키면</br>
이후에는 아예 정상작동하지 않는 모습을 보여주었다.</br>
</br>
이렇게 사용한 함수가 FreeLibrary 함수이다.</br>
</br>
이 함수에 대해 찾아보니</br>
굉장히 엄청난 함수였는데</br>
말 그대로 메모리에서 지워버리는 함수였다.</br>
그러면 Load를 하면 되는거 아니냐고 하겠지만</br>
Load는 그냥 메모리에 올리는 역할만 하는 것 같았다.</br>
내가 만약에 함수 A를 Dllimport를 사용하는 도중</br>
FreeLibrary를 통해 해당 DLL을 메모리에서 해제시켜버리면</br>
함수 A는 더이상 참조할 곳이 없어지게 되고 크래시가 발생하게 된다.</br>
</br>
이 상태에서 LoadLibrary를 통해 로드를 시켜주면</br>
해당 DLL라이브러리는 메모리에 올라가져있는 상태가 되지만</br>
함수 A는 참조하는 곳이 없어져버린 이상한 상태에 머물러져 있다.</br>
함수 A는 DLL라이브러리가 이미 해제되어버린 이상한 공간을 참조하고 있으므로</br>
이 함수를 새롭게 할당된 DLL라이브러리 공간으로 할당해주는 작업이 필요하다.</br>
</br>
그런데 새롭게 할당해주는 작업 같은 경우</br>
처음부터 동적으로 불러오는 식으로 만들어주지 않았다면</br>
힘들 것 같다.</br>
그리고 일일히 하나하나 함수들을 연결해주어야 하기 때문에</br>
꽤 귀찮은 작업이 될 것이다.</br>
</br>
그렇기 때문에 FreeLibrary는 해제를 해버리고</br>
두번 다시 사용을 안 하겠다하면 사용하는 함수 같다.</br>
실제로 LoadLibrary도 dllimport가 되어있었지만</br>
아무 곳에서도 사용하지 않고 있었다.</br>
</br>
아무튼 굉장히 엄청난 함수에 대해 알 수 있었는데</br>
정작 제대로된 사용은 못해봐서</br>
나중에 기회가 된다면 꼭 사용해보고 싶다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담
```
일단 오늘 야근을 하는 바람에
작성이 늦어졌다.

퇴근하고 밥 먹고 하면 12시가 넘을 것 같아
대충 임시 파일을 만들고 커밋해서 초록점은 채웠다.

그리고 실제 작성은 25일에 하고 있는 중이다.

회사에서 작성해도 되지만
퇴근이 너무 늦어질 것 같아.
어쩔 수가 없었다.

오늘도 디버깅을 했는데
산 넘어 산이다.

기존 로직에도 누수가 있었지만
새롭게 추가한 로직에도 누수가 있었다.
물론 기존 로직도 해당되는 내용이다.

그래서 솔직히 이번 주에는 메모리 누수가 무조건 끝날줄 알았는데
더욱 길어질 예정이다.
```