# 비동기는 언제 끝나는지 모른다

대충 이런 코드가 있다고 해보자
```
함수 A 실행();
함수 B 실행();
함수 C 실행();
```
보통의 경우 이 코드의 진행은 다음과 같이 된다.</br>
A 함수 실행 -> A 함수 종료 -> B 함수 실행 -> B 함수 종료 -> C 함수 실행 -> C 함수 종료</br>
-> 프로그램 종료</br>
ㅇㅇ
</br>
말 그대로 코드가 작성된 순서대로 코드가 실행이 되고</br>
한 줄이 종료가 되어야 다음 줄이 실행이 된다.</br>
그러니깐 보이는대로 코드가 실행되기 때문에</br>
실행 순서에 따른 이것저것에 대해 생각하지 않아도 된다.</br>
</br>
이게 동기적 프로그래밍인데</br>
비동기는 이와 반대 된다고 생각하면 된다.</br>
</br>
대충 이런 코드가 있다고 해보자
```
함수 A 비동기 실행();
함수 B 비동기 실행();
함수 C 비동기 실행();
```
이 코드의 진행은 다음과 같다.</br>
A 함수 실행 -> B 함수 실행 -> C 함수 실행 -> 프로그램 종료</br>
</br>
위의 예제와 다른 점이 뭐냐면</br>
해당 코드는 `실행` 만 시켜준다.</br>
함수가 종료가 되었는지 아닌지는 상관하지 않고</br>
`실행` 만 시켜준다.</br>
그러고 프로그램이 종료가 된다.</br>
</br>
그러면 함수는 어디서 실행이 되냐 할 수 있는데</br>
사실 프로그램이 종료되는 게 아니라</br>
쓰레드가 종료가 된다.</br>
</br>
메인 쓰레드에서 해당 코드를 작성해서 실행을 한다면</br>
메인 쓰레드는 딱 실행 역할만 하고 끝이 난다.</br>
대신 함수 A, B, C를 돌리는 쓰레드들은 독립적으로 돌아가고 있는 것이다.</br>
</br>
독립적으로 돌아가기 때문에</br>
함수의 실행 순서는 중요하지 않게 된다.</br>
함수의 실행 순서와 상관 없이 빨리 끝나면 빨리 끝나는대로 함수는 리턴된다.</br>
</br>
함수 A가 먼저 실행이 되었더라도</br>
모종의 이유로 함수 B가 먼저 종료될 수도 있고</br>
함수 C가 먼저 종료 될 수도 있다.</br>
</br>
이러한 점 때문에 비동기로 코드를 작성하면</br>
굉장히 많은 오류가 발생할 수 있다.</br>
</br>
이를테면 함수 A는 클래스를 초기화 하고</br>
함수 B는 초기화 된 클래스를 참조 한다고 생각해보자</br>
</br>
함수 B가 정상적으로 동작하려면</br>
함수 A가 클래스를 초기화 해줘야 할 것이다.</br>
즉, 함수 A가 정상 종료된 이후 함수 B가 실행이 되어야</br>
오류가 발생하지 않는다는 것인데</br>
</br>
이 두개의 함수를 비동기로 작성하게 된다면</br>
함수 A가 끝나는 시점이 보장되어있지 않고</br>
이 말인 즉슨, 클래스가 초기화 되지 않는 상태에서</br>
함수 B가 실행 될 수도 있다는 소리이고</br>
이것은 오류를 발생시킬 수 있다.</br>
</br>
이러한 차이 때문에 비동기로 무엇인가 동작을 시키는 것은</br>
굉장히 조심해야 한다.</br>
</br>
그런데 이렇게 비동기로 작성을 해야 할 수 밖에 없는 상황이 오고</br>
비동기 함수가 끝났을 때 무엇인가 동작을 시켜야 할 수도 있다.</br>
이를테면 네트워크를 이용한 코드가 이런 경우가 많은데</br>
</br>
함수 A는 네트워크에 접속해서 파일을 다운로드 하는 함수라고 해보자.</br>
이것을 메인 쓰레드에서 돌린다면</br>
프로그램은 함수 A가 끝날 때 까지 동작을 멈출 수 밖에 없을 것이다.</br>
왜냐하면 파일을 다운로드 받는 동안은 함수 A가 메인 쓰레드를 점유하고 있기 때문이다.</br>
</br>
그런데 무엇인가 다운로드를 받는 다는 것은</br>
굉장히 느린 행위에 속하기 때문에</br>
이것을 메인 쓰레드가 아닌 독립적으로 돌리는 경우가 많다.</br>
</br>
이 경우 함수 A에서 파일 다운로드가 끝났을 때</br>
어떠한 행위를 추가해주고 싶을 때가 있을 것이다.</br>
이를테면 다운로드 완료 팝업을 띄운다던가 하는 식이다.</br>
</br>
그러면 해당 함수가 끝났는지 아닌지를 체크해야하는 코드가 있어야 하는데</br>
그것을 수행해줄 수 있는 다양한 방법들이 존재한다.</br>
</br>
첫번째로는 플래그를 추가해주는 방법이 있다.</br>
bool 변수 하나를 추가해줘서</br>
함수가 끝나면 해당 변수를 true로 만들어 주는 것이다.</br>
</br>
그리고 해당 변수를 체크하는 함수를 하나 만들어줘서</br>
해당 변수가 true가 되면 함수 B를 실행해주도록 만들어주면 된다.</br>
</br>
그런데 이 방법의 단점은</br>
비동기 이후 함수를 실행시키고 싶을 때마다</br>
플래그를 계속해서 추가시켜주어야 한다는 것이다.</br>
</br>
두번째 방법으로는 이벤트를 이용하는 방법이 있다.</br>
함수 A 마지막 부분에 이벤트를 실행시키는 코드를 넣어준다.</br>
그러면 함수 A가 종료될 때 이벤트를 실행시켜줄 것이므로</br>
그냥 이벤트에 함수 B를 등록만 해주면 함수 A가 끝나는 시점에</br>
알아서 함수 B가 실행 될 것이다.</br>
</br>
근데 이건 체크해주는 함수가 빠질 뿐이지</br>
비동기 이후 함수를 실행 시켜야 할 때마다</br>
해당 비동기 함수를 위한 이벤트를 만들어주어야 한다는 단점이 있다.</br>
</br>
또 다른 방법은 이와 비슷하긴 한데</br>
콜백을 활용하는 방식이다.</br>
함수 A에 파라미터로 콜백이라는 것을 넣어주고</br>
함수 A를 실행 시킬 때 파라미터로 함수 B를 넣어주면</br>
함수 A가 끝날 때 알아서 함수 B가 실행 될 것이다.</br>
</br>
콜백은 마지막 시점에 알아서 함수가 실행 될 것이며</br>
파라미터만 넣어주면 되기 때문에 조금 더 간편 할 것 같다.</br>
</br>
아무튼 많은 방법이 있을 것인데</br>
보통 이벤트와 콜백 2개를 많이 활용하는 것 같다.</br>
</br>
아무튼 언제 끝날지 모른다는 점을 항상 염두해두면서 코드를 짜야한다.</br>
그렇지 않으면 나도 모르게 동기적으로 코딩을 하게 되고</br>
그러면 꼭 오류가 발생하는 코드를 작성하게 되기 때문이다.</br>
</br>
아예 비동기인 코드는 당연히 해당되는 이야기 이지만</br>
유니티에선 비동기 처럼 사용 할 수 있는 코루틴에도 당연히 해당되는 이야기 이다.</br>
</br>
코루틴이 완전 비동기는 아니기 때문에</br>
비동기에서 발생할 수 있는 다양한 오류들 중 상당수는 없어질 것이지만</br>
그럼에도 불구하고 많은 오류들이 생길 수 있기 때문에</br>
언제 끝날 지 모른다는 점은 꼭 유의해서 작성해야 할 것이다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담
```
일단 비동기 작성을 했는데
비동기 특징이 이것 뿐만은 아니라
어떻게 해야할 지 고민이긴 하다.

이걸로 몇일 더 때울지
아니면 그냥 새로운 주제로 넘어갈지

근데 너무 부족하긴 한 것 같다.
```