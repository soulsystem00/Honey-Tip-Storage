# 오브젝트 레퍼런스는 함부로 만들면 안된다

이번에 디버깅을 진행하면서</br>
요런 코드를 사용했다.</br>

```
var allObjects = Resources.FindObjectsOfTypeAll(typeof(Object)).ToArray();
```

왜냐하면 메모리 누수가 일어났는데 원인을 특정하지 못했기 때문에</br>
일단 오브젝트 리스트를 만들고 전과 후의 리스트를 비교해서</br>
새롭게 생성되거나 사라지지 않는 것들을 통해 원인을 파악해보려 했기 때문이다.</br>
</br>
전과 후의 리스트를 비교하기 위해선</br>
전 단계에 해당하는 오브젝트 리스트를 캐싱을 해야했고</br>
그렇게 그냥 당연하게 파괴가 안되는 오브젝트에서 저장할 수 있도록 만들어주었다.</br>
</br>
그렇게 해서 비교를 진행을 하니</br>
다시 처음으로 돌아올 때 마다 오브젝트 카운트가 증가하는 것을 볼 수 있었는데</br>
이상하게 프로파일러 상에서 굉장히 티가 많이 났다는 것이다.</br>
</br>
만약에 프로파일러에서 이렇게 까지 티가 났다면</br>
분명히 이전에 테스트를 진행하면서 한번이라도 발견이 되었을 것이라 생각을 했다.</br>
이러한 의문점을 가지고 프로파일러를 살펴봤는데</br>
레퍼런스 카운트가 없는데도 불구하고 메모리에서 해제되지 않는 모습을 볼 수 있었고</br>
다행히도 프로파일러에서 해당 오브젝트를 참조하고 있는 오브젝트를 살펴볼 수 있었다.</br>
</br>
그곳을 살펴보니 해당 오브젝트를 전혀 사용하지 않는 곳에서 참조를 하고 있었는데</br>
자세히 살펴보니 리스트를 비교하기 위해서 캐싱을 해놓은 곳에서 참조를 하고 있다고 뜬 것이다.</br>
</br>
결론적으로 리스트에서 참조를 하고 있으니</br>
해당 오브젝트는 사용을 하고 있다고 판단하고</br>
해제를 시켜주지 않았던 것이다.</br>
</br>
그렇게 오브젝트가 해제되지 않으니</br>
이전에 사용하고 있던 것들은 당연히 남아있고</br>
거기에 새롭게 생긴 오브젝트까지 추가가 되니</br>
해당 리스트엔 계속해서 오브젝트가 쌓이는 거고</br>
메모리도 계속해서 증가했던 것이다.</br>
</br>
이러한 원인을 알고나니 굉장히 허무했지만</br>
온전히 나의 실수이므로 뭐라 할 말이 없었다.</br>
누수를 해결하기 위해 열심히 테스트를 진행했는데</br>
다시 원래대로 돌아온 꼴이 되어버렸다.</br>
</br>
이전에 작성했던 글 대로</br>
결국 누수 원인은 찾지 못했고 임시방편으로 틀어막았다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담

```
오늘 일단 이슈 때문에 대기상태라
이걸 작성 안하면 집가면 늦을 것 같아서
일단 작성을 했다.
```