
# 유니티는 멀티쓰레드 지원이 안된다

옛날옛적 유니티를 접하고 게임을 만들다가</br>
멀티플레이를 만들어야 하는 상황이 벌어졌다.</br>
</br>
만약에 지금 만든다고 하면 포톤을 사용할 것 같다.</br>
그런데 그 당시에는 이런 것들을 배울 시간 없이</br>
현재 내가 알고 있는 지식으로 구현을 해야만 하는 상황이었다.</br>
</br>
멀티플레이는 결국 내 컴퓨터와 상대방의 컴퓨터가 서로 정보를 주고 받아야했고</br>
그 상황에서 내가 해봤던 방법은 TCP 통신 채팅 프로그램이 끝이었다.</br>
그래서 이걸 가져다가 사용하기로 결정했다.</br>
</br>
대충 로직은 이렇다.</br>
A를 소환했으면 A라고 채팅을 보내준다.</br>
그러면 A를 받은 친구는 A를 소환한다.</br>
이게 끝이다.</br>
</br>
서로 채팅을 할 수 있게 만들어주고</br>
채팅 메세지에 따라 함수 동작을 넣어주는 식으로 만들어주었다.</br>
그리고 이 채팅을 위해 메세지를 받는 쓰레드를 만들어주었고</br>
그 쓰레드 안에 A를 받으면 A 소환, B를 받으면 B를 소환 하는 코드를 넣어주었다.</br>
</br>
그런데 오류가 발생했다.</br>
</br>
메인 쓰레드가 아닌 곳에서는 유니티 함수를 사용 못한다는 것이었다.</br>
그래서 유니티 함수를 쓰지 않고 구현을 해주었다.</br>
그럼에도 불구하고 오류가 발생했다.</br>
</br>
왜냐하면 기본형이 아닌 유니티에서 제공하는 클래스, 자료형 등등에 접근하는 순간</br>
비슷한 오류가 떴기 때문이다.</br>
</br>
그래서 이것에 대해 찾아보기 시작하였는데</br>
그때 알게 된 것이 유니티는 멀티쓰레드를 제공하지 않는다는 것이었다.</br>
그러니깐 결국 유니티는 메인 쓰레드 하나로만 동작을 하고 있다는 뜻이었다.</br>
</br>
처음에 이 문구를 보고선 굉장히 어이가 없었다.</br>
유니티라는 굉장히 발전된 엔진에서 멀티쓰레드를 지원하지 않는다는 것은</br>
그만큼 프로그램 적으로 제한이 굉장히 많이 발생한다는 뜻으로 받아들여졌기 때문이다.</br>
하지만 점점 코딩을 할 수록 이 부분에 대해 점차 이해가 가기 시작했다.</br>
</br>
중요한 것은 내가 과연 멀티쓰레드 환경에서</br>
공유되는 자원을 오류 없이 관리를 할 수 있을까 이다.</br>
나는 아니라고 본다.</br>
</br>
멀티쓰레드에 대해 알아가면 알아갈수록</br>
생각할 것도 굉장히 많아지고 생각을 하면 할 수록 복잡해진다.</br>
그래서 처음에는 그냥 하면 되지 라고 생각을 했지만</br>
점점 자신감이 없어진다.</br>
</br>
그런데 대중적인 엔진에서 멀티쓰레드를 지원하는 순간</br>
그 여파는 굉장히 엄청나게 퍼질 것이라고 생각한다.</br>
</br>
잘 쓰는 사람은 좋은 프로그램을 만들 수 있을 테지만</br>
엔진 자체의 난이도가 굉장히 올라갈 것이고</br>
그만큼 안정성도 떨어질 것이기 때문이다.</br>
</br>
공유되는 자원에 여러개의 쓰레드가 동시에 접근을 하는 순간</br>
데드락이 걸릴 가능성이 굉장히 높아지며</br>
이러한 상황에 대비를 하지 않는 이상</br>
언젠가는 게임에 오류가 발생할 것이다.</br>
</br>
이러한 환경을 만들바에</br>
차라리 지원을 하지 않는 편이 나을수도 있겠다는 생각이 들었다.</br>
</br>
대신 이를 대체할 수 있는 기능을 만들어주었는데</br>
바로 코루틴이다.</br>
</br>
코루틴을 사용하면</br>
마치 멀티쓰레드 처럼 코딩을 할 수 있게 된다.</br>
중요한 것은 멀티쓰레드 처럼 이라는 문구인데</br>
결국 멀티쓰레드는 아니라는 말이다.</br>
</br>
코루틴은 양보라는 개념으로 돌아가게 되는데</br>
코루틴의 로직이 돌아가다 일정 조건을 충족하면</br>
자신을 멈추고 유니티에게 권한을 양보한다.</br>
그리고 다시 다음 프레임에 자신의 차례가 오면 자신의 로직을 돌리는 식으로 동작한다.</br>
</br>
그렇기 때문에 이 양보하는 조건을 무조건 적어줘야 하며</br>
코루틴이 무한루프에 걸려서 양보를 하지 못하는 상황이 오면</br>
게임도 같이 무한루프 속에 갇혀버린다.</br>
</br>
결국은 메인쓰레드 안에서 돌아가기 때문이다.</br>
</br>
그렇기 때문에 무작정 코루틴을 사용하면 안되고</br>
이러한 개념에 대해 잘 알고 써야한다.</br>
물론 내가 잘 알고 있다는 뜻은 아니다.</br>
</br>
이러한 코루틴도 당연히 단점이 있는데</br>
첫째로는 관리가 어렵다는 점이다.</br>
명확하게 서술하기가 애매하긴 하지만</br>
쓰다보면 제어가 잘 안된다는 느낌을 받았다.</br>
제어를 하려면 할 순 있겠지만 그 과정이 굉장히 귀찮은 경우가 많았다.</br>
</br>
또한 협업을 함에 있어서</br>
코드를 보기가 어려워지는 경우가 굉장히 많았다.</br>
어떠한 동작이 이뤄지고 있으면 분명히 그 동작을 유발시키는 코드가 존재하고 있다는 뜻인데</br>
그 곳이 어디인지 찾기 어려운 경우가 많았고</br>
또 하나의 코루틴을 계속해서 껐다가 켰다가 해버리면</br>
더더욱 추적하기 어려운 경우도 많았다.</br>
</br>
게다가 잘 사용하는 사람이 쓰면 모르겠는데</br>
이상하게 사용하는 사람이 작성한 코드를 보면 암 걸릴 것 같은 경우가</br>
한 두번이 아니었다.</br>
</br>
이러한 과정 속에 하나의 문구를 알게 되었는데</br>
Fire and forget이다.</br>
마치 로켓을 발사하듯 코루틴을 동작시키고 잊어버리라는 것이다.</br>
</br>
그래서 최대한 그러려고 하고 있다.</br>
그냥 StartCoroutine을 시키기만 하고</br>
StopCoroutine을 사용한다던가 하진 않는다.</br>
그러기 위해서 최대한 코루틴으로 발사시킬 수 있는 로직들만</br>
코루틴으로 만드려고 노력하고 있다.</br>
</br>
또 다른 단점으로는 가비지인데</br>
보통 코루틴을 사용하면 yield return new WaitforSecond()라는 구문을 자주 사용하는데</br>
결국 new로 메모리를 할당해주므로 메모리가 많이 쌓일 수 밖에 없다.</br>
또한 그냥 한번으로 끝내면 괜찮은데</br>
보통은 반복문 안에서 yield를 시키는 경우가 많으니</br>
많은 메모리가 쌓일 것이고 빈번한 GC를 일으킬 것이다.</br>
</br>
물론 캐싱을 하면 해결이 가능하지만</br>
코딩을 하다보면 이를 스킵하는 경우도 많으니</br>
단점이 되는 경우가 많은 것 같다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담
```
흠 코루틴이 나왔으니

다음 주제는 비동기가 될 것 같다.

근데 점점 주제가 없어지고 있다.

그나마 긍정적인 면이라면
어떻게든 주제를 찾고자
새로운 것을 공부해보려고 하고 있다는 것이다.
```