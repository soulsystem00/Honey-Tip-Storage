# 쿼터니온에서 오일러의 변환은 이상하게 된다

```
Quarternion.Euler(x, y, z);

Vector3 eulerAngle = transform.rotation.eulerAngles;
```

</br>
해당 코드는 오일러 각으로 주어진 회전각도를 쿼터니온으로 변환시켜주고</br>
쿼터니온을 다시 오일러 각으로 변환시켜주는 코드이다.</br>
회전에 대해 직관적으로 생각할 수 있는 것이 오일러 각이기 때문에</br>
해당 코드들을 정말 많이 사용하고 있다.</br>
</br>
또한 쿼터니온에 대한 완벽한 이해가 없어서 쿼터니온을 직접 컨트롤 하지 못하기 때문에</br>
오일러 각으로 대입하고 싶을 때, 회전을 컨트롤 하고 싶을 때 해당 코드들을 사용하고 있다.</br>
</br>
그러다가 굉장히 이상한 현상을 보게 되었는데</br>
내가 사용한 코드는 다음과 같다.</br>
</br>

```
transform.rotation = Quaternion.Euler(180, 0, 0);

transform.eulerAngles = new Vector3(180, 0, 0); // 둘이 같다.
```
굉장히 단순한 코드인데</br>
분명히 x에 180을 y와 z에는 0을 대입했음에도 불구하고</br>
유니티 인스펙터 창에서는 x에 0 y에 180 z에 -180이 들어간 것을 볼 수 있었다.</br>
</br>
중간에 내가 뭔가 다른 코드를 넣었다 하고 해당 코드를 주석처리를 해보니</br>
트랜스폼의 회전값의 변화는 없었다.</br>
즉, 해당 코드로 대입을 시킨 결과가 다음과 같다는 것인데</br>
분명히 나는 x에만 값을 대입시켰음에도 불구하고</br>
결과 값은 이상하게 나온 것이다.</br>
</br>
그래서 내가 직접 `x`만 `180`돌려보고, `y, z`를 해당 값대로 돌려본 결과를 비교해봤는데</br>
둘의 회전된 결과는 똑같았다.</br>
</br>
그렇게 해서 내가 내린 결론은 다음과 같다.</br>
</br>

1. 위 코드는 오일러 각을 쿼터니온으로 변환만 시켜준다.

2. 인스펙터 창에 뜨는 값은 쿼터니온을 오일러 각으로 **다시** 변환시킨 결과이다.

3. 두번의 변환 과정에 의해 `처음 대입한 값`과 `다시 변환 된 값`의 차이가 발생한다.

4. 다만 회전된 결과를 보자면 둘이 동일한 결과를 갖는다.

</br>

그래서 `Quaternion.Euler(180, 0, 0)`과 `Quaternion.Euler(0, 180, -180)`이 </br>
쿼터니온으로는 어떻게 표현이 되는지 확인을 해보려고 했는데</br>
둘이 다르게 표현이 되는 걸 볼 수 있었다.</br>
</br>
그리고 이번엔 갑자기 0,180,-180으로 뜨는게 아니라 -180,0,0으로 뜨는 걸 볼 수 있었다.</br>
도대체가 뭔 차이 인지를 모르겠다.</br>
</br>
아무튼 결론을 내자면</br>
내가 대입한 오일러 각대로 회전은 되지만</br>
인스펙터 창에는 내가 대입한 오일러 각과 다르게 표현될 수 있다는 것이다.</br>
그러니깐 내가 대입한 오일러 각을 무조건 맹신하지 말고</br>
또 내가 대입한 오일러 각대로 뜨지 않는다고 버그라고 생각은 안해도 된다는 것이다.</br>
</br>
진짜 회전은 너무 복잡한 것 같다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담
```
언젠가 한번쯤은 회사에서 이걸 작성하는 날이 올 거라고 생각했는데
이렇게 빨리 올 줄은 몰랐다.

어쩌다 보니 야근을 하게 되었는데
집가서 바로 뻗으려면 이걸 작성해놓고 가는게 좋을 것 같다는 생각이 들었는데
마침 시간이 남기도 해서 이걸 작성을 했다.

근데 진짜 쿼터니온은 너무 복잡한 것 같다.
적어도 내가 대입한 오일러 각을 다시 내뱉을 줄 알았는데
그러지 않는다는게 너무 당황스러웠다.

몸살은 거의 다 나은 것 같다.
약간의 가래가 끼지만 어차피 이건 낫는 과정 이라는 증거니깐
약간 불편하긴 해도 괜찮은 것 같다.
```