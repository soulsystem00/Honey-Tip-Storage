# 유니티에서 SetWindowLong은 다르게 적용해야 한다

SetWindowLong은 윈도우 창의 속성을 변경해주는 함수이다.</br>

함수의 원형은 다음과 같다.</br>
```
[DllImport("user32")]
public static extern Int32 SetWindowLong(IntPtr hWnd, Int32 nIndex, Int32 dwNewLong);
```
[함수 설명](https://learn.microsoft.com/ko-kr/windows/win32/api/winuser/nf-winuser-setwindowlonga)

공식 문서 참고하면 되는데</br>
대충 정리를 하자면</br>

hWnd는 변경할 윈도우 창의 핸들을 의미한다.</br>

nIndex는 변경할 속성을 의미한다.</br>
C++에서는 이미 Define이 되어 있는 것 같은데</br>
C#에서는 따로 Define을 해주던가 귀찮으면 그냥 int로 넣어버리면 된다.</br>
각 값이 의미하는 것은 공식 문서 참고하면 된다.</br>
</br>
dwNewLong은 바꿀 값이다.</br>
여기에 넣은 값으로 바꾸겠다는 의미이다.</br>
</br>
이 함수의 리턴 값은 바꾸기 전의 값이다.</br>
예를 들어서 윈도우 창이 1이라는 값을 가지고 있다고 할 때</br>
이것을 2로 바꾼다면</br>
함수는 1을 리턴한다.</br>
</br>
이렇게 저장된 이전 값은 윈도우 창을 다시 원복 시킬 때 사용하면 된다.</br>
</br>
</br>
아무튼 윈도우 창의 속성을 변경하기 위해서</br>
어떤 윈도우 창을 변경할 것 인지에 대한 핸들을 가져와야 하는데</br>
보통 FindWindow 함수로 핸들을 가져오게 된다.</br>
</br>
FindWindow 함수는 이전에 설명을 했으니깐</br>
그걸 참고하면 될 것 같고</br>
아무튼 보통 창을 찾으려면 윈도우 창의 이름으로 찾는 경우가 많은데</br>
유니티 에디터에서는 클래스 명으로 찾는 경우가 많다.</br>
</br>
왜냐하면 윈도우 창 이름이 너무 복잡하다.</br>
윈도우 창 제목을 살펴보면</br>
유니티 버전, 몇 비트인지, 씬 이름, 프로젝트 이름, 타겟 플랫폼 등등</br>
여러가지 정보들이 들어있다.</br>
이걸 정확하게 타이핑 해서 넣어주어야 유니티 창을 찾을 수 있을텐데</br>
이걸 타이핑 하기엔 너무 시간이 오래걸리고</br>
너무 길다보니 타이핑을 하다 오타가 날 수도 있기 때문이다.</br>
</br>
그런데 클래스 명 같은 경우에는 `UnityContainerWndClass`로 일정하다.</br>
그래서 코드를 작성 할 때 굉장히 편리해진다는 장점이 있다.</br>
그냥 한번 작성해두면 다음 프로젝트 만들 때도 그냥 그 코드 가져다가 쓰면 된다.</br>
클래스로 찾으면 코드의 재사용이 쉬워진다.</br>
</br>
대신 빌드 상태일 때와 에디터 모드일 때 FindWindow 사용법이 다르니</br>
현재 플랫폼에 따라 분기를 나눠주는 식으로</br>
코드를 작성하고 있다.</br>

```
if (Application.platform == RuntimePlatform.WindowsPlayer)
{
    // 대충 WindowName으로 FindWindow후 SetWindowLong 하는 코드
}
else if (Application.platform == RuntimePlatform.WindowsEditor)
{
    // 대충 ClassName으로 FindWindow후 SetWindowLong 하는 코드
}

```

</br>
그런데 중요한 점은 에디터 모드에선 게임을 종료해도</br>
윈도우 창은 종료되지 않는다는 특징이 있다.</br>
</br>
이 말인 즉슨</br>
내가 SetWindowLong으로 윈도우 창을 변경했으면</br>
게임을 종료해서 변경한 내용이 계속해서 남아있다는 뜻이 된다.</br>
</br>
이 상태에서 게임을 다시 실행하면</br>
윈도우 창의 속성이 바뀌겠지만</br>
이전에 남아있던 값이 윈도우 기본 값이 아닌 내가 설정한 값이 되버리고</br>
이는 생각했던 것과 다른 오류를 만들어 낼 수 있다.</br>
</br>
그렇기 때문에</br>
에디터 모드이건 아니건 간에</br>
꼭 윈도우 창을 다시 이전 값으로 원복시켜주는 코드가 필요하다.</br>
</br>
빌드상태일 땐 필요가 없긴 하지만</br>
혹시 모르기 때문이다.</br>
</br>
</br>
</br>
</br>
</br>
# 잡담

```
이걸 몰라가지고
무한 루프가 발생해서 유니티가 팅긴 적이 한 두번이 아니다.
유니티가 팅기면 보통 엔진 오류인 경우가 많아서
그냥 넘어가기도 했는데

이건 한두번도 아니고 계속 특정 구간에서 팅기니깐
이 부분에대해 확이능 해보니
내가 SetWindowLong을 하는 부분에서 팅긴 것이었다.

그리고나서 이후 코드 진행을 확인해보니
이전 값을 다시 불러와서 사용하는 코드가 있었는데

이전 값이 내가 등록한 커스텀 코드가 되버리고
내가 등록한 커스텀 코드는 이전 값을 다시 불러와서 사용하는 코드였고

그게 무한 반복을 일으키고
스택 초과를 하면서 팅긴 것이었다.

이렇게 몇번 팅겨보니
이후에는 비슷한 증상이 생기면 오류를 잡기 쉬워졌지만
여전히 해당 오류를 만난다.

왜냐하면 이전 작업자가 게임 종료시 초기화를 해주는 코드를 생략했기 때문이다.


그리고 비동기 같은 경우에는
꼭 작성을 할거다
오늘 갑자기 이 오류를 만나서
너무 화가나서 작성을 할 수 밖에 없었다.
```




