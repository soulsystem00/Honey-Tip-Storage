# 이벤트는 계속 등록하면 안된다

```
void Update()
{
    button.onClick.Addlistener(() =>
    {
        Debug.log("Clicked!!");
    });
}
```

요딴식으로 이벤트 등록하면 안된다.</br>
</br>
그러니깐 저 함수가 onClick 이벤트에 계속 등록이 된다.</br>
이벤트에 함수를 등록할 때 같은 함수면 등록이 안되거나 하지 않는다.</br>
코드 적으로 뭔가 중복을 체크하지 않으면 그냥 등록이 되버린다.</br>
그러면 등록한 횟수만큼 함수가 실행이 된다.</br>
</br>
저 함수처럼 눈으로 보여지는 것이면 빠르게 찾을 수 있을텐데</br>
눈으로 보여지지 않고 여러번 등록이 되어도</br>
동작 자체는 문제가 없는 함수가 있을 수 있다.</br>
그런 함수가 어딨냐 하겠지만 내가 겪었다.</br>
</br>
그런 경우에는 동작에는 문제가 없으니 된거 아니냐 하겠지만</br>
저따구로 사용을 하면</br>
메모리 누수가 발생한다.</br>
</br>
이벤트의 내부 구조를 모른다 하더라도 대충 따져보면</br>
이벤트를 등록하면 뭔가 함수의 위치를 저장 할 것이고</br>
그 말인 즉슨, 함수의 위치를 저장 하는 저장 공간이 필요해진다는 이야기이다.</br>
그런데 저런식으로 계속해서 함수를 등록하면</br>
함수의 위치가 계속해서 저장이 될 것이고</br>
그 함수의 위치를 저장 할 저장 공간이 필요해진다는 이야기이다.</br>
</br>
그 저장공간이 함수 1개면 얼마 되지 않겠지만</br>
60프레임 기준으로 1초에 60개의 함수가 등록이 되고</br>
1분에 3600개의 함수가 등록이 되고</br>
1시간에 216000개의 함수가 등록이 되면</br>
상당한 크기를 가질 것이다.</br>
</br>
메모리 누수 이외의 다른 문제점이라고 한다면</br>
바로 속도에 있는데</br>
이벤트를 발동하면</br>
이벤트에 등록되어 있는 함수들을 선회하면서 동작시킬 것이다.</br>
그런데 그 함수가 굉장히 많다면</br>
그것들을 한번 선회하는데 굉장히 많은 시간이 소모될 것이다.</br>
</br>
그렇기 때문에 절대 저딴식으로 이벤트를 등록하면 안된다.</br>
이벤트는 함수의 중복이 가능하다.</br>
</br>
이를 막기 위한 방법을 꼽자면</br>
프로퍼티를 사용하면 될 것이다.</br>
```
private Action onClick;
public Action OnClick
{
    add
    {
        onClick -= value;
        onClick += value;
    }
    remove
    {
        onClick -= value;
    }
}
```
대충 요런식으로 작성하면 되는데</br>
이벤트의 -= 연산은 이벤트에 해당 함수가 없더라도</br>
예외를 발생시키지 않는다.</br>
그래서 저런 식으로 사용하게 되면</br>
굉장히 편리하게 이벤트 내부에서 함수의 중복을 피할 수 있게 된다.</br>
</br>
물론 맨위의 코드처럼 람다를 사용하면 안 먹힐 것이다.</br>
그래서 이벤트를 등록할 땐 람다를 사용하지 않는 걸 추천한다.</br>
</br>
아무튼 굉장히 신선한 오류였었다.</br>
메모리 누수를 잡으면서 발견을 했었는데</br>
당연한 이야기이고 당연히 오류가 생길거라 생각했는데</br>
당연하지 않게 오류가 발생하지 않아서</br>
더더욱 신기했던 것 같다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담
```
원래는 비동기 쓸려했는데

갑자기 이게 떠올라서 미뤘음

근데 진짜 이건 신기했던 오류였음

내가 겪었을 땐 오류가 나야했는데 오류가 안나서 더욱 신기했었음

그래서 오류를 잡기 어려웠을 수도 있었는데

다행이도 하나씩 주석처리 해가면서 찾으니

비교적 쉽게 찾을 수 있던 오류였음
```