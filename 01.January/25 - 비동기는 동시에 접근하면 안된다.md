# 비동기는 동시에 접근하면 안된다.

사실 동시에 접근해도 됨</br>
자신이 있으면</br>
</br>
근데 동시에 접근하다가 피를 보는 경우가 많음</br>
그래서 이런 경우를 여러 곳에서 다양한 방법으로 동시 접근을 막고 있음</br>
</br>
단순히 변수에 접근 하는건 가능할지 몰라도</br>
조금이라도 영향을 줄 가능성이 있는 경우에는 </br>
윈폼이던 유니티 건 예외를 발생시킴</br>
</br>
윈폼 같은 경우에는 각 UI요소들에 쓰레드를 통해 접근을 한다면</br>
어떨때는 잘 넘어갈 때도 있지만 보통은 크로스쓰레드 예외를 발생시키고</br>
</br>
유니티 같은 경우에는 유니티 모노어쩌구는 쓰레드에서 호출하지 못한다는 예외를 발생시킴</br>
</br>
</br>
이러한 이유는 아마 쓰레드를 사용했을 때 발생할 수 있는</br>
여러가지 문제점들을 사전에 예방하기 위함일 것이라 생각함</br>
</br>
대충 예시는 아래와 같은데

```
static int count = 0;

static void Main(string[] args)
{
    Console.WriteLine("Hello World");

    Thread t1 = new Thread(new ThreadStart(IncreaseCnt));
    Thread t2 = new Thread(new ThreadStart(IncreaseCnt));

    t1.Start();
    t2.Start();

    Console.WriteLine("Main Thread End");
}

private static void IncreaseCnt()
{
    for (int i = 0; i < 1000000; i++)
    {
            count++;
    }

    Console.WriteLine($"IncreaseCnt Finish : {count}");
}
```
대충 카운트 증가하는 함수가 있는데 쓰레드 2개에서 돌릴거임</br>
한 쓰레드에서 1000000번 증가시키고</br>
다른 쓰레드에서도 10000000번 증가시킬 거임</br>
그러면 대충 결과는 20000000이 나올거라 생각할 수도 있지만</br>
당연하게도 20000000이 아니라 이상한 값이 나옴</br>
</br>
왜 그런가 살펴보면</br>
++ 연산은 대충 3단계로 볼 수 있는데</br>
1. 변수A 에서 값을 가져온다.</br>
2. 값을 증가시킨다.</br>
3. 변수A에 값을 넣는다.</br>

대충 이런 순서일 텐데 </br>
쓰레드에서 동시에 접근하면 저 순서가 엉켜버림</br>
대충 엉키는 예시가 이럼

1. 쓰레드 1에서 변수 값(0)을 가져온다.
---------------------------------------------------
2. 쓰레드 2에서 변수 값(0)을 가져온다.
3. 쓰레드 2에서 값(0)을 증가시킴 -> 값(1)
4. 쓰레드 2에서 값을 대입시킴 변수 값(1)이 됨
---------------------------------------------------
5. 쓰레드 1에서 값(0)을 증가시킴 -> 값(1)
6. 쓰레드 1에서 값을 대입시킴 변수 값(1)이 됨

분명히 값을 2번 증가시켰는데</br>
결과 값은 1이 됨</br>
ㅈㄴ 이상함</br>
</br>
이걸 컨트롤 할 수 있으면</br>
동시에 접근하면 됨</br>
</br>
대충 여러가지 방법이 있는데</br>
일단 bool 변수를 써서 접근 가능한지 체크하는 방법이 있을 거라 생각했는데</br>
안된다.</br>
</br>
왜냐하면 역시가 위의 케이스 처럼 예외가 발생하는 경우가 있음</br>
만약에 isUsed 변수가 true라서 false로 만들고 값을 수정하려고 하는 도중에</br>
갑자기 다른 쓰레드에서 false가 되기전에 접근을 한다면 역시나 오류가 발생함</br>
</br>
</br>
가장 쉬운 방법은 lock을 사용하는 거임</br>
대충 요런 식으로 만들면 됨</br>

```
private static void IncreaseCnt()
{
    for (int i = 0; i < 1000000; i++)
    {
        lock (lockObj)
        {
            count++;
        }
    }

    Console.WriteLine($"IncreaseCnt Finish : {count}");
}
```
카운트를 증가시키기전 락을 걸어서</br>
다른 쓰레드에서 접근을 못하게 만드는 거임</br>
그러면 다른 쓰레드에서 접근을 하려고 하면</br>
lock이 걸려있으니깐 lock이 풀릴 때 까지 대기하게 됨</br>
lock이 풀리면 연산이 진행 되고</br>
</br>
그런데 당연히 이것에도 문제가 있는데</br>
lock을 잘못걸면</br>
dead lock이 발생함</br>
</br>
쓰레드 A에서는 a를 잠그고 b에 접근하려고 하고</br>
쓰레드 B에서 b를 잠구고 a에 접근하려고 하면</br>
두 쓰레드 중 하나가 풀려야 다른 하나도 풀리는 상황이 되고</br>
한 쪽이 라도 안 풀리면 먹통이 되어버리는 이상한 상황이 발생함</br>
</br>
그래서 lock을 쓸 때 신중하게 사용해야 함</br>
</br>
</br>
그리고 비동기를 사용하는 이유가</br>
어떻게 보면 동시에 처리하게 만들기 위해서 인데</br>
한쪽이 처리하고 있을 때 다른 한쪽에서 처리를 못하고 대기를 한다는 것은</br>
비동기의 위력이 낮아진다는 소리가 됨</br>
</br>
물론 어쩔 수 없는 부분도 있겠지만</br>
이상적인 그림에선 멀어지는 부분도 있음</br>
</br>
</br>
아무튼 동시 접근을 하면 굉장히 다양한 문제들이 발생할 수 밖에 없고</br>
이걸 어느정도 막아버렸지만</br>
그럼에도 불구하고 동시 접근 하려면 얼마든지 동시 접근을 할 수 있는 상황이고</br>
그렇기 때문에 동시 접근을 하려면 주의를 해야한다는 것이다.</br>
</br>
</br>
</br>
</br>
</br>
### 잡담
```
일단 디버깅 건은 아직도 해결하지 못했음
껐다 켰다 반복하면 메모리가 누수가 됨

그래서 싹다 비활성화 시키고 껐다 켰다만 해봤는데
메모리가 누수가 됨

근데 이건 진짜 말도 안되는게
그런 상황이면 다른 곳에서도 문제가 발생했어야 하는데
문제가 발생하지 않았고

그리고 진짜 껐다 켰다고 문제가 발생한 거면
내가 해결 할 수 있는 부분이 아님;

인게임에도 누수가 있는 것 같은데
너무 할게 많은 것 같음
```
