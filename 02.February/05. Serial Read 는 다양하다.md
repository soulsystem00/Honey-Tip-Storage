# Serial Read 는 다양하다

C# SerialPort 클래스 안에는 굉장히 다양현 Read 메소드가 있다.</br>
그래서 이걸 적절히 잘 활용하면 편리하게 사용이 가능하고</br>
파싱을 하는데 있어서도 큰 도움이 된다.</br>
</br>
다만 각자 특징이 존재하기 때문에 이러한 것들을 잘 유의해서 사용해야 한다.</br>
</br>

## 그냥 Read
```
public int Read (byte[] buffer, int offset, int count);
public int Read (char[] buffer, int offset, int count);
```

그냥 기본형이다.</br>
byte or char 배열에 값을 받아올 수 있는데</br>
얼마나 받아올 것인지 특정해서 받아올 수 있다.</br>
</br>
단점으로는 일일히 배열을 만들어주어야 한다.</br>
이런 경우에는 `Serial.BytesToRead` 를 사용해서</br>
버퍼에 있는 바이트 크기를 얻어와서 배열을 만들어주는 식으로 사용이 가능하다.</br>
</br>
혹은 큰 배열을 미리 선언해서 받아올 수도 있긴 한데</br>
이런 경우 쓸데없이 큰 공간을 차지하는 경우가 생길 수도 있고</br>
큰 배열이라 할지라고 버퍼에 그 이상이 쌓여있는 경우 모든 값을 못 받아올 수도 있다.</br>
</br>
그리고 버퍼의 크기 이상으로 받아오도록 설정하면 오류가 나는 걸로 알고 있다.</br>
그러면 결국 `Serial.BytesToRead` 를 사용해야한다.</br>
</br>
어쩌면 불편할 수도 있는 메소드 인 것 같다.</br>
</br>
</br>
## 바이트 하나만 받아오는 ReadByte
```
public int ReadByte ();
```
말 그대로 바이트 하나만 받아온다.</br>
이걸 사용하면 굉장히 직관적으로 코드를 짤 수 있다.</br>
반복문 안에서 버퍼에 값이 있으면 ReadByte를 하는 식으로 코드를 만들고</br>
이렇게 받아온 값을 버퍼에 쌓는 식으로 짜면 된다.</br>
</br>
그리고 보통 프로토콜 형식이 있을텐데</br>
이렇게 일일히 받아온 값을 검사하는 식으로 코드를 짜면</br>
파싱을 크게 신경쓰지 않아도 되는 것 같다.</br>
</br>
단점으로는 느리다.</br>
일일히 하나씩 받아오는 방식이기 때문에</br>
느리다.</br>
</br>
그렇기 때문에 이렇게 일일히 받아오다가</br>
뒤쪽에 데이터가 밀릴 수도 있다.</br>
그래서 파싱에 덜 신경써도 되지만 데이터가 밀리는 건 신경을 써야한다.</br>
그래서 잘 안쓰는 것 같다.</br>
</br>
</br>
## 문자 하나만 받아오는 ReadChar
```
public int ReadChar ();
```
이것 역시 `ReadByte`와 비슷한데</br>
테스트를 안해봐서 모르겠는데 문자인코딩에 따라 단일 바이트를 읽지 못할 수도 있다고 한다.</br>
이게 뭔 소린지 모르겠는데</br>
정상적으로 읽히지 않는 경우가 있다는 것 같다.</br>
이후에 나올 케이스와 비슷하지 않을까 생각이 된다.</br>
</br>
이건 거의 안쓰는 듯</br>
</br>
</br>
## 버퍼에 있는 걸 모두 읽어오는 ReadExisting
```
public string ReadExisting ();
```
메소드 이름 그대로 버퍼에 있는 모든 값을 읽어온다.</br>
그래서 한번에 싹 읽어와서 처리를 해주면 되기 때문에</br>
파싱에만 신경쓰면 되는 것 같다.</br>
</br>
그런데 굉장히 큰 단점이 있는데 아스키 영역의 값만 읽는다는 사실이다.</br>
Byte 값은 0x00 ~ 0xFF 가 되는데 아스키 영역은 0x7F 까지이다.</br>
그 이후의 값이 들어오면 이상한 값으로 변환이 되어서 들어온다.</br>
</br>
만약에 프로토콜이 아스키 영역에서만 사용이 된다면 상관이 없겠지만</br>
코드 테이블 영역의 값도 사용하게 된다면 이건 사용하지 못한다.</br>
</br>
이걸 모르고 사용했다가 고생했던 기억이 있다.</br>
아스키 코드만 읽는다는 걸 기억하자</br>
</br>
그리고 string으로 들어오기 때문에</br>
파싱을 해야한다면 byte 배열로 변환을 따로 해주어야 한다.</br>
</br>
</br>
## 한 줄만 읽어오는 ReadLine
```
public string ReadLine ();
```
말 그대로 한 줄만 읽어온다.</br>
그런데 이 한 줄의 기준이 뭐냐면 결국 `\n` 문자가 된다.</br>
그러니깐 상대방이 메세지를 보내줄 때 맨 뒤에 `\n` 을 붙여서 줘야한다는 소리이다.</br>
만약에 그렇지 않는다면 Read를 하지 못하는 상황이 온다.</br>
</br>
프로토콜의 영향을 굉장히 많이 받는 메소드인 것 같다.</br>
</br>
만약에 보내줄 때 개행문자로 끊어서 주는 방식이면 굉장히 편리하게 사용이 가능하겠지만</br>
그렇지 않는다면 아예 사용하지 못하는 메소드이다.</br>
</br>
그리고 결국 한 줄만 받아오기 때문에</br>
그 이후의 문자들은 버퍼에 남아있게 된다.</br>
받아오는 곳의 속도가 굉장히 빠르면 상관이 없겠지만</br>
데이터를 받는 속도가 느리면 계속해서 버퍼에 쌓이게 될 것 이다.</br>
</br>
</br>
## 특정 부분까지 읽어오는 ReadTo
```
public string ReadTo (string value);
```
이건 ReadLine의 확장형이라고 생각하면 될 것 같다.</br>
ReadLine은 개행문자까지 읽어오는 거라면</br>
이건 내가 따로 커스텀을 해서 어디까지 읽어올 것인지 정할 수 있다.</br>
</br>
단점으로는 마찬가지로 버퍼에 데이터가 쌓일 가능성이 있다는 것이다.</br>
프로토콜에 따라 유연하게 대처가 가능하겠지만 데이터가 쌓인다는 점 때문에</br>
많이 사용하지 않는 것 같다.</br>
</br>
</br>
아무튼 굉장히 많은 Read 메소드가 있는데</br>
상황에 따라 편리한 것을 사용하면 될 것 같다.</br>
가장 좋은 것은 ReadExisting인 것 같다.</br>
데이터가 쌓일 일이 없기 때문이다.</br>
쌓여도 쌓인 것 까지 받아버리기 때문이다.</br>
</br>
다만 파싱을 잘 만들어 주어야 할 것 같다.</br>
</br>
</br>
</br>
### 잡담
```
일단 작성을 했다.
일단 자려고 했는데
아무리 생각해도 작성을 해놓고 자야할 것 같았다.

어쨌든 사정이 있어서 밀린 건데
이런 식으로 계속해서 하루하루 밀리다보면
결국 작성을 안할 게 뻔했기 때문이다.

아마 이번주는 계속 야근 할 것 같은데
그러면 더더욱 작성을 안할 것 같았다.

그리고 딱봐도 조금 늦게 잘 것 같은데
작성도 안해놓고 늦게 자는게 말이 안되기도 했다.

이번주 업무는 아마 굉장히 힘들 것으로 예상이 된다.
```