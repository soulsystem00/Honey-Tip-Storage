# SequenceEqual로 배열을 비교하자

2개의 배열이 같은지를 비교하려고 다음과 같은 코드를 짯음  
```
int[] arr = new int[] { 1, 2, 3, 4 };
int[] arr2 = new int[] { 1, 2, 3, 4 };

Console.WriteLine(arr == arr2);
```

진짜 별거 없음  
걍 배열 2개가 있고 배열의 원소도 같음  
그리고 C# 을 믿었음  
내가 아는 C#이라면 분명히 == 연산자가 오버로딩이 되어있을 것이라고  
</br>
그런데 그런 기대와는 다르게  
해당 연산자는 false를 반환했음  
</br>
처음에 저렇게 코드를 짜고  
왜 안되지? 하고 궁금해 했었는데  
찾아보니 저렇게 비교를 하면 배열의 원소가 아니라  
객체를 비교하는 거라고 함  
이를테면 객체의 이름이라던가 객체의 instanceID라던가  
</br>
저 두개의 배열은 분명히 다른 new를 통해서 인스턴스화 시켰기 때문에  
분명히 다른 객체이고  
그렇기 때문에 false가 리턴이 되는 것이었음  
그러니깐 저기서 == 연산자는 `두 객체가 같은 객체인가?` 에 해당하는 연산이었고  
당연히 false를 리턴 할 수 밖에 없었음  
</br>
그렇기 때문에 두 배열의 원소가 같은지 확인을 하기 위해선  
반복문을 통해 원소 하나씩 비교를 하던가  
다른 방법을 사용해야 함  
</br>
일단 반복문을 사용하는 방법 같은 경우에는  
많은 예외사항들이 발생할 수 밖에 없다는 생각이 들었음  
코드도 길어지고  
분명히 한줄로 끝낼 수 있는 방법이 있을 것이라 생각했음  
</br>
그렇게 찾아본 결과  
SequenceEqual 이라는 함수를 찾을 수 있었음  
</br>
해당 함수를 사용하면  
두 배열 간의 원소가 같은지 비교를 할 수 있음  
</br>
사용 방법은 다음과 같음  

```
int[] first = { 1, 4, 5, 2, 4 };
int[] second = { 1, 4, 5, 2, 4 };

bool isEqual = first.SequenceEqual(second);
```

first에서 함수를 끌어와 사용했지만  
어차피 같은지 다른지를 비교하는 것이기 때문에  
그 순서는 상관이 없을 것 같음  
</br>
그런데 이 함수의 단점이라고 한다면  
원소의 순서까지 동일해야한다는 것임  
만약에 배열 a의 원소가 1,2,3,4,5 이고  
배열 b의 원소가 5,4,3,2,1 이라면  
분명히 존재하는 원소는 동일한데  
그 순서가 다르기 때문에 false를 리턴 할 것임  
</br>
이를 해결하기 위한 간단한 방법이 있는데  
바로 정렬을 해버리는 거임  

```
int[] first = { 1, 4, 5, 2, 4 };
int[] second = { 1, 4, 5, 2, 4 };

bool isEqual = first.OrderBy(a => a).SequenceEqual(second.OrderBy(a => a));
```
</br>
요런 식으로 정렬을 해서 비교를 하면  
두 배열이 순서에 상관 없이 동일한 원소를 가지고 있는지  
비교를 할 수가 있음  
추가로 orderby 함수는 원본을 유지하고 정렬된 배열을 새롭게 만들어주기 때문에  
원본 배열에는 영향이 없음
</br>
</br>
</br>
</br>
</br>
### 잡담  

```

```