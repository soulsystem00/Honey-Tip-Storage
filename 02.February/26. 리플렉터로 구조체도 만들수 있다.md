# 리플렉터로 구조체도 만들수 있다

```
Activator.CreateInstance<structType>();
```
이전 글과 동일한 주제인데  
클래스를 인스턴스화 시킨 코드와 동일한 코드를 사용해서  
구조체도 동일하게 생성이 가능하다.  

그런데 구조체와 클래스의 성격차이  
즉, 약간의 뭔가가 다른 용도의 차이 때문에  
이렇게 생성을 한 구조체에서 문제를 발견 할 수 있었는데  
바로 초기화의 문제이다.  

그런데 클래스 같은 경우에는 이렇게 인스턴스화를 해도  
생성자를 통해서 기본 값으로의 초기화가 가능한데  
구조체는 생성자를 가질 순 있지만  
매개변수가 없는 생성자는 가질 수가 없다.  
(C# 10.0 이상에선 가능하다고 뜨긴 한다.)  

그렇기 때문에 이렇게 구조체를 만들게 된다면  
뭔가 자동으로 이뤄지는 초기화가 이뤄지지 않기 때문에  
따로 초기화를 해주어야 한다.  
</br>
</br>
그런데 일단 내가 구조체를 이런 식으로 생성하게 된 이유는  
CSV에서 구조체를 불러오는 식으로 코드를 작성했기 때문인데  

대충 csv에서 키 값과 벨류 값을 받아온 후  
구조체를 생성하고 해당 구조체에 벨류 값을 넣어주는 식으로  
코드를 생성하고 싶었다.  

그냥 배열로 받아온 값을 순서대로 구조체의 변수에 넣어줘도 상관은 없었겠지만  
문제는 구조체마다 가지고 있는 변수가 다르다는 점이었고  
그렇기 때문에 저런 식으로 순서대로 변수에 넣어주는 식이라면  
각 구조체마다 코드를 만들어주어야 했다.  

그렇기 때문에 어떤 구조체라도 상관 없이  
같은 함수를 사용해서 csv에서 구조체의 값을 받아오도록 만드려면  
csv에서 키 값을 받아오고 그 키 값으로 구조체의 변수를 찾아서  
해당 변수에 벨류를 넣는 식으로 구현을 해줘야 했다.  

그리고 그 방법을 위해 사용한 것이 바로 아래의 함수들이다.  

```
System.Reflection.FieldInfo field = typeof(T).GetField("Key String");

field.SetValue(struct, value);
```

`GetField` 함수는 문자열을 통해 필드 정보를 받아올 수 있다.  
만약에 없으면 null이 뜨는 것 같다.  

게다가 필드 명과 문자열이 정확하게 일치해야한다.  
처음에는 대소문자 구분 없이 코드를 작성했는데  
필드 정보를 못받아오는 걸 볼 수 있었다.  

왜 대소문자 구분을 없애고 싶었냐면  
csv에서 키 값을 불러오는 방식이기 때문에  
대소문자가 일치하지 않는 경우가 있을 수도 있었기 때문이다.  

이를테면 코드에선 변수명을 myCount로 작성을 했지만  
csv에선 Mycount로 작성될 수도 있고 MYCOUNT로 작성될 수도 있었기 때문이다.  
특히나 csv는 외부에서 수정이 너무 쉽기 때문에  
대소문자를 틀릴 가능성이 농후하기도 했다.  
그래서 오타는 어쩔 수 없지만 대소문자는 구분 없이 만들어보고 싶었는데  
괜찮은 방법을 찾지 못했다.  
그래서 이 부분은 무조건 대소문자까지 일치해야 한다.  

그리고 `SetField` 는 이렇게 받아온 필드 정보를  
오브젝트에 할당해주는 역할을 하는 것 같다.  

그런데 처음 이 코드를 사용했을 때 문제가 된 점이 무엇이었냐면  
오류는 뜨지 않았다.  
그런데 할당이 이뤄지지 않았다.  

그래서 해당 부분에 대해 찾아보니  
박싱을 해주어야 한다는 것이었다.  
그래서 구조체를 생성할 때 object 타입에 할당을 해주는 식으로  
만들어주었다.  

그래서 완성한 코드의 대략적인 모습은 아래와 같다.  

```
object item = System.Activator.CreateInstance<T>();
for (int j = 0; j < header.Length; j++)
{
    System.Reflection.FieldInfo field = typeof(T).GetField(header[j].ToLower());
    if (field != null)
    {
        if (field.FieldType == typeof(int))
        {
            field.SetValue(item, int.Parse(data));
        }
        else if (field.FieldType == typeof(float))
        {
            field.SetValue(item, float.Parse(data));
        }
        else if (field.FieldType == typeof(string))
        {
            field.SetValue(item, data);
        }
        else if (field.FieldType == typeof(bool))
        {
            field.SetValue(item, data.Equals("1"));
        }
    }
}
```

뭐 대충 위에서 설명한 내용들이 다 들어가 있다.  
오브젝트 타입으로 박싱을 해서 구조체를 생성하고  
이렇게 박싱한 구조체에서 키 문자열을 통해 필드 정보를 가져오고  
이렇게 가져온 필드 정보에서 타입별로 파싱을 해서 값을 할당해주었다.  

이렇게 하면 여러 구조체에 대응하는  
자동으로 구조체를 생성해주고 초기화를 해주는 코드를 만들 수 있다.  
근데 정말 특별한 상황에서만 사용할 것 같다.  
</br>
</br>
</br>
</br>
</br>
### 잡담  

```
너무 밀려버렸다.  
```