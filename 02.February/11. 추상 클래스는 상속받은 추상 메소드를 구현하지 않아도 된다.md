# 추상 클래스는 상속받은 추상 메소드를 구현하지 않아도 된다

클래스 구조를 짜면서  
굉장히 여러가지 상황에 맞닥뜨리는 것 같은데  
이것 역시 많은 상황 중에 하나이다.  
</br>
처음에 추상 클래스 A를 만들어주었고  
그 안에 추상 메소드를 하나 선언해주었다.

```
abstract class A
{
    public abstract void Foo();
}
```

보통 같으면 A를 상속받는 일반 클래스를 만들고  
해당 클래스에서 추상 클래스를 구현해줬을 것이다.  
</br>
그런데 어쩌다 보니 A를 상속받는 추상 클래스가 만들어지게 되었다.  

```
abstract class B : A
{

}
```

그런데 보통 추상 클래스를 상속받는 클래스를 만들면  
추상 메소드를 구현해야한다는 오류가 뜨면서 빨간줄이 그어지게 되는데  
이건 그런 오류가 뜨지 않는 걸 볼 수 있었다.  
</br>
추상 클래스를 상속받았으니  
추상 클래스라 하더라도 추상 메소드를 어떤 식으로든 구현해줘야 할 줄 알았는데  
그렇지 않는다는 점이 신기했다.  
</br>
물론 추상 클래스, 추상 메소드에 대해 생각을 해보면  
당연한 일 일 수도 있는데  
직접 겪게 되니 많이 신기했었다.  
</br>
물론 상속 받은 추상 메소드를 오버라이딩하는 추상 메소드를 만들수는 있는 것 같다.

```
 abstract class A
{
    protected abstract void Foo();
}

abstract class B : A
{
    protected override abstract void Foo();
}

class C : B
{
    protected override void Foo()
    {

    }
}

```

이게 뭐 쓸 일이 있을 진 모르겠지만  
아무튼 이게 가능하다는 걸 알게 되었다.  
상속이라는 게 쓰면 쓸수록 복잡해지는 것 같다.  
</br>
</br>
</br>
</br>
</br>
### 잡담

```
그러니깐 추상 메소드 상속 받으면
무조건 추상 메소드를 오버라이드 해줘야 하는 줄 알았는데
추상 메소드에선 그러지 않아도 된다는 게 신기해서
올리는 거다.

근데 프로젝트가 커지고
만약에 저런 상황이 오면
그냥 B에다가 오버라이딩 해줄 것 같다.
왜냐하면 굳이굳이 A까지 찾아서 들어가지 않고
그냥 파악하게 만들고 싶기 때문이다.
```